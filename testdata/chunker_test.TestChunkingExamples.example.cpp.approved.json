{
  "file": "example.cpp",
  "language": "cpp",
  "chunks": [
    {
      "Content": "#include \u003calgorithm\u003e\n#include \u003ciostream\u003e\n#include \u003cmemory\u003e\n#include \u003cstdexcept\u003e\n#include \u003cstring\u003e\n#include \u003cvector\u003e\n",
      "StartLine": 1,
      "EndLine": 7,
      "StartByte": 0,
      "EndByte": 116,
      "NodeTypes": [
        "#include",
        "preproc_include",
        "system_lib_string"
      ],
      "Language": "cpp"
    },
    {
      "Content": "namespace datastructures",
      "StartLine": 8,
      "EndLine": 8,
      "StartByte": 117,
      "EndByte": 141,
      "NodeTypes": [
        "namespace",
        "namespace_identifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "{\n\n/**\n * Template class for a dynamic array with automatic resizing\n */",
      "StartLine": 8,
      "EndLine": 12,
      "StartByte": 142,
      "EndByte": 214,
      "NodeTypes": [
        "comment"
      ],
      "Language": "cpp"
    },
    {
      "Content": "template \u003ctypename T\u003e",
      "StartLine": 13,
      "EndLine": 13,
      "StartByte": 215,
      "EndByte": 236,
      "NodeTypes": [
        "template",
        "template_parameter_list",
        "type_identifier",
        "type_parameter_declaration",
        "typename"
      ],
      "Language": "cpp"
    },
    {
      "Content": "class DynamicArray",
      "StartLine": 13,
      "EndLine": 13,
      "StartByte": 237,
      "EndByte": 255,
      "NodeTypes": [
        "class",
        "type_identifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "{\nprivate:\n  std::unique_ptr\u003cT[]\u003e data;\n  size_t capacity;\n  size_t length;\n\n  static constexpr size_t INITIAL_CAPACITY = 10;\n  static constexpr double GROWTH_FACTOR = 1.5;\n\n  /**\n   * Resize the internal array to the new capacity\n   */",
      "StartLine": 13,
      "EndLine": 24,
      "StartByte": 256,
      "EndByte": 492,
      "NodeTypes": [
        "abstract_array_declarator",
        "access_specifier",
        "comment",
        "constexpr",
        "field_declaration",
        "field_identifier",
        "namespace_identifier",
        "number_literal",
        "primitive_type",
        "private",
        "qualified_identifier",
        "static",
        "storage_class_specifier",
        "template_argument_list",
        "template_type",
        "type_descriptor",
        "type_identifier",
        "type_qualifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "void resize(size_t new_capacity) {\n    auto new_data = std::make_unique\u003cT[]\u003e(new_capacity);\n\n    for (size_t i = 0; i \u003c length; ++i) {\n      new_data[i] = std::move(data[i]);\n    }\n\n    data = std::move(new_data);\n    capacity = new_capacity;\n  }\n\n  /**\n   * Ensure capacity is sufficient for additional elements\n   */",
      "StartLine": 25,
      "EndLine": 38,
      "StartByte": 495,
      "EndByte": 813,
      "NodeTypes": [
        "abstract_array_declarator",
        "argument_list",
        "assignment_expression",
        "auto",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "declaration",
        "expression_statement",
        "field_identifier",
        "for",
        "for_statement",
        "function_declarator",
        "function_definition",
        "identifier",
        "init_declarator",
        "namespace_identifier",
        "number_literal",
        "parameter_declaration",
        "parameter_list",
        "placeholder_type_specifier",
        "primitive_type",
        "qualified_identifier",
        "subscript_argument_list",
        "subscript_expression",
        "template_argument_list",
        "template_function",
        "type_descriptor",
        "type_identifier",
        "update_expression"
      ],
      "Language": "cpp"
    },
    {
      "Content": "void ensure_capacity(size_t required_capacity) {\n    if (required_capacity \u003e capacity) {\n      size_t new_capacity = std::max(\n          required_capacity, static_cast\u003csize_t\u003e(capacity * GROWTH_FACTOR));\n      resize(new_capacity);\n    }\n  }\n\npublic:\n  /**\n   * Constructor with optional initial capacity\n   */\n  explicit DynamicArray(size_t initial_capacity = INITIAL_CAPACITY)\n      : data(std::make_unique\u003cT[]\u003e(initial_capacity)),\n        capacity(initial_capacity), length(0) {}\n\n  /**\n   * Copy constructor\n   */",
      "StartLine": 39,
      "EndLine": 57,
      "StartByte": 816,
      "EndByte": 1333,
      "NodeTypes": [
        "abstract_array_declarator",
        "access_specifier",
        "argument_list",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "declaration",
        "explicit",
        "explicit_function_specifier",
        "expression_statement",
        "field_identifier",
        "field_initializer",
        "field_initializer_list",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "init_declarator",
        "namespace_identifier",
        "number_literal",
        "optional_parameter_declaration",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "public",
        "qualified_identifier",
        "template_argument_list",
        "template_function",
        "type_descriptor",
        "type_identifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "DynamicArray(const DynamicArray \u0026other)\n      : data(std::make_unique\u003cT[]\u003e(other.capacity)), capacity(other.capacity),\n        length(other.length) {\n    for (size_t i = 0; i \u003c length; ++i) {\n      data[i] = other.data[i];\n    }\n  }\n\n  /**\n   * Move constructor\n   */\n  DynamicArray(DynamicArray \u0026\u0026other) noexcept\n      : data(std::move(other.data)), capacity(other.capacity),\n        length(other.length) {\n    other.capacity = 0;\n    other.length = 0;\n  }\n\n  /**\n   * Copy assignment operator\n   */",
      "StartLine": 58,
      "EndLine": 78,
      "StartByte": 1336,
      "EndByte": 1836,
      "NodeTypes": [
        "abstract_array_declarator",
        "argument_list",
        "assignment_expression",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "const",
        "declaration",
        "expression_statement",
        "field_expression",
        "field_identifier",
        "field_initializer",
        "field_initializer_list",
        "for",
        "for_statement",
        "function_declarator",
        "function_definition",
        "identifier",
        "init_declarator",
        "namespace_identifier",
        "noexcept",
        "number_literal",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "qualified_identifier",
        "reference_declarator",
        "subscript_argument_list",
        "subscript_expression",
        "template_argument_list",
        "template_function",
        "type_descriptor",
        "type_identifier",
        "type_qualifier",
        "update_expression"
      ],
      "Language": "cpp"
    },
    {
      "Content": "DynamicArray \u0026operator=(const DynamicArray \u0026other) {\n    if (this != \u0026other) {\n      data = std::make_unique\u003cT[]\u003e(other.capacity);\n      capacity = other.capacity;\n      length = other.length;\n\n      for (size_t i = 0; i \u003c length; ++i) {\n        data[i] = other.data[i];\n      }\n    }\n    return *this;\n  }\n\n  /**\n   * Move assignment operator\n   */",
      "StartLine": 79,
      "EndLine": 94,
      "StartByte": 1839,
      "EndByte": 2188,
      "NodeTypes": [
        "abstract_array_declarator",
        "argument_list",
        "assignment_expression",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "const",
        "declaration",
        "expression_statement",
        "field_expression",
        "field_identifier",
        "for",
        "for_statement",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "init_declarator",
        "namespace_identifier",
        "number_literal",
        "operator",
        "operator_name",
        "parameter_declaration",
        "parameter_list",
        "pointer_expression",
        "primitive_type",
        "qualified_identifier",
        "reference_declarator",
        "return",
        "return_statement",
        "subscript_argument_list",
        "subscript_expression",
        "template_argument_list",
        "template_function",
        "this",
        "type_descriptor",
        "type_identifier",
        "type_qualifier",
        "update_expression"
      ],
      "Language": "cpp"
    },
    {
      "Content": "DynamicArray \u0026operator=(DynamicArray \u0026\u0026other) noexcept {\n    if (this != \u0026other) {\n      data = std::move(other.data);\n      capacity = other.capacity;\n      length = other.length;\n\n      other.capacity = 0;\n      other.length = 0;\n    }\n    return *this;\n  }\n\n  /**\n   * Add an element to the end of the array\n   */",
      "StartLine": 95,
      "EndLine": 109,
      "StartByte": 2191,
      "EndByte": 2507,
      "NodeTypes": [
        "argument_list",
        "assignment_expression",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "expression_statement",
        "field_expression",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "namespace_identifier",
        "noexcept",
        "number_literal",
        "operator",
        "operator_name",
        "parameter_declaration",
        "parameter_list",
        "pointer_expression",
        "qualified_identifier",
        "reference_declarator",
        "return",
        "return_statement",
        "this",
        "type_identifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "void push_back(const T \u0026value) {\n    ensure_capacity(length + 1);\n    data[length++] = value;\n  }\n\n  /**\n   * Add an element using move semantics\n   */\n  void push_back(T \u0026\u0026value) {\n    ensure_capacity(length + 1);\n    data[length++] = std::move(value);\n  }\n\n  /**\n   * Remove and return the last element\n   */",
      "StartLine": 110,
      "EndLine": 125,
      "StartByte": 2510,
      "EndByte": 2820,
      "NodeTypes": [
        "argument_list",
        "assignment_expression",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "const",
        "expression_statement",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "namespace_identifier",
        "number_literal",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "qualified_identifier",
        "reference_declarator",
        "subscript_argument_list",
        "subscript_expression",
        "type_identifier",
        "type_qualifier",
        "update_expression"
      ],
      "Language": "cpp"
    },
    {
      "Content": "T pop_back() {\n    if (length == 0) {\n      throw std::out_of_range(\"Cannot pop from empty array\");\n    }\n    return std::move(data[--length]);\n  }\n\n  /**\n   * Access element at index with bounds checking\n   */\n  T \u0026at(size_t index) {\n    if (index \u003e= length) {\n      throw std::out_of_range(\"Index out of bounds\");\n    }\n    return data[index];\n  }",
      "StartLine": 126,
      "EndLine": 141,
      "StartByte": 2823,
      "EndByte": 3172,
      "NodeTypes": [
        "argument_list",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "namespace_identifier",
        "number_literal",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "qualified_identifier",
        "reference_declarator",
        "return",
        "return_statement",
        "string_content",
        "string_literal",
        "subscript_argument_list",
        "subscript_expression",
        "throw",
        "throw_statement",
        "type_identifier",
        "update_expression"
      ],
      "Language": "cpp"
    },
    {
      "Content": "/**\n   * Const version of at()\n   */\n  const T \u0026at(size_t index) const {\n    if (index \u003e= length) {\n      throw std::out_of_range(\"Index out of bounds\");\n    }\n    return data[index];\n  }\n\n  /**\n   * Array subscript operator\n   */\n  T \u0026operator[](size_t index) { return data[index]; }\n\n  /**\n   * Const array subscript operator\n   */",
      "StartLine": 143,
      "EndLine": 160,
      "StartByte": 3176,
      "EndByte": 3509,
      "NodeTypes": [
        "argument_list",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "const",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "namespace_identifier",
        "operator",
        "operator_name",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "qualified_identifier",
        "reference_declarator",
        "return",
        "return_statement",
        "string_content",
        "string_literal",
        "subscript_argument_list",
        "subscript_expression",
        "throw",
        "throw_statement",
        "type_identifier",
        "type_qualifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "const T \u0026operator[](size_t index) const { return data[index]; }\n\n  /**\n   * Get current size of the array\n   */\n  size_t size() const { return length; }\n\n  /**\n   * Check if array is empty\n   */\n  bool empty() const { return length == 0; }\n\n  /**\n   * Clear all elements\n   */",
      "StartLine": 161,
      "EndLine": 175,
      "StartByte": 3512,
      "EndByte": 3788,
      "NodeTypes": [
        "binary_expression",
        "comment",
        "compound_statement",
        "const",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "number_literal",
        "operator",
        "operator_name",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "reference_declarator",
        "return",
        "return_statement",
        "subscript_argument_list",
        "subscript_expression",
        "type_identifier",
        "type_qualifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": "void clear() { length = 0; }\n\n  /**\n   * Reserve capacity without changing size\n   */\n  void reserve(size_t new_capacity) {\n    if (new_capacity \u003e capacity) {\n      resize(new_capacity);\n    }\n  }\n\n  /**\n   * Get current capacity\n   */\n  size_t get_capacity() const { return capacity; }\n}",
      "StartLine": 176,
      "EndLine": 191,
      "StartByte": 3791,
      "EndByte": 4079,
      "NodeTypes": [
        "argument_list",
        "assignment_expression",
        "binary_expression",
        "call_expression",
        "comment",
        "compound_statement",
        "condition_clause",
        "const",
        "expression_statement",
        "field_identifier",
        "function_declarator",
        "function_definition",
        "identifier",
        "if",
        "if_statement",
        "number_literal",
        "parameter_declaration",
        "parameter_list",
        "primitive_type",
        "return",
        "return_statement",
        "type_qualifier"
      ],
      "Language": "cpp"
    },
    {
      "Content": ";",
      "StartLine": 191,
      "EndLine": 191,
      "StartByte": 4079,
      "EndByte": 4080,
      "NodeTypes": [],
      "Language": "cpp"
    },
    {
      "Content": "}",
      "StartLine": 193,
      "EndLine": 193,
      "StartByte": 4082,
      "EndByte": 4083,
      "NodeTypes": [],
      "Language": "cpp"
    },
    {
      "Content": "// namespace datastructures",
      "StartLine": 193,
      "EndLine": 193,
      "StartByte": 4084,
      "EndByte": 4111,
      "NodeTypes": [
        "comment"
      ],
      "Language": "cpp"
    }
  ]
}